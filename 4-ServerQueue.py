import math
import random
 
# Random variable library for generating random variables
#import numpy

# Global Variables:

# Current time variable
t = 0.0

# Time of line switch
ts = 0.0

# Departure times for 4-server
td1 = 0.0
td2 = 0.0
td3 = 0.0
td4 = 0.0

# Deparature times for 5-server
t5d1 = 0.0
t5d2 = 0.0
t5d3 = 0.0
t5d4 = 0.0
t5d5 = 0.0

# Closing time variable
tc = 100.0

# Initialize line lists
# Line lists will contain customers represented by an integer number of items in cart
line1 = list()
line2 = list()
line3 = list()
line4 = list()

# Initialize State Variables
n1 = 0
n2 = 0
n3 = 0 
n4 = 0


# Total number of customer arrivals throughout the day
totalArrivals = 0

# Initialize r.v. generation parameters

# Arrival time parameter
lam = 0.5

# Cart size parameter
cartSizeLam = 0.5

# Generates arrival time, along with number of items in cart
def generateArrivalTime(lam):
	# Non-homogenous Poisson distribution
	# random variable u
	u = random.random()
	# Set New Arrival time to exponential equation
	Y = (-lam) * math.log(1 - u)
	ta = Y + t
	return ta

# Initialize first arrival time
ta = generateArrivalTime(lam)

#Parker
#def generateDepartureTime():
	# If customer is at the front of the line -> generate departure time using weibull dist.
	# 

def updateTime(eventTime):
	# Adds event time to current time
	t += eventTime

def getTime():
	return t

#Parker
def getItemsInCart(line):
	# Return number of items in first current customer's cart (first customer in line)
	return line[len(line) - 1].numItems

#Jack
# Generated by exponential random variable (?)
# Should return an integer
def generateItemsInCart():

	# Generate uniform random variable
	u = random.random()

	# Returns number of items in cart 
	return math.ceil(40*(-cartSizeLam)*math.log(1 - u))

#Eric
#def getEstimatedWaitTime(line):
	# Returns line (which is a list)

# Returns shortest estimated line
# Return value is the line that the customer chooses
def chooseLine(numItems):
	# Case 1 (Customer is allowed to use express lane): 
	if (numItems > 15):
		if min(getEstimatedWaitTime(line1), getEstimatedWaitTime(line2), getEstimatedWaitTime(line3), getEstimatedWaitTime(line4)) == getEstimatedWaitTime(line1):
			return line1
		elif min(getEstimatedWaitTime(line1), getEstimatedWaitTime(line2), getEstimatedWaitTime(line3), getEstimatedWaitTime(line4)) == getEstimatedWaitTime(line2):
			return line2
		elif min(getEstimatedWaitTime(line1), getEstimatedWaitTime(line2), getEstimatedWaitTime(line3), getEstimatedWaitTime(line4)) == getEstimatedWaitTime(line3):
			return line3
		else: 
			return line4
	# Case 2 (Customer is not allowed to use express lane):
	else:
		if min(getEstimatedWaitTime(line1), getEstimatedWaitTime(line2), getEstimatedWaitTime(line3), getEstimatedWaitTime(line4), getEstimatedWaitTime(line5)) == getEstimatedWaitTime(line1):
			return line1
		elif min(getEstimatedWaitTime(line1), getEstimatedWaitTime(line2), getEstimatedWaitTime(line3), getEstimatedWaitTime(line4), getEstimatedWaitTime(line5)) == getEstimatedWaitTime(line2):
			return line2
		elif min(getEstimatedWaitTime(line1), getEstimatedWaitTime(line2), getEstimatedWaitTime(line3), getEstimatedWaitTime(line4), getEstimatedWaitTime(line5)) == getEstimatedWaitTime(line3):
			return line3
		elif min(getEstimatedWaitTime(line1), getEstimatedWaitTime(line2), getEstimatedWaitTime(line3), getEstimatedWaitTime(line4), getEstimatedWaitTime(line5)) == getEstimatedWaitTime(line4):
			return line4
		else: 
			return line5


# Returns the soonest deparature time among all the lines
def getNextDepartureTime():
	return min(td1, td2, td3, td4)

# Adds customer with specified properties to a line list
def addCustomerToLine(customer, line):
	line.push(customer)
	if (line == line1):
		n1 += 1
	elif (line == line2):
		n2 += 1
	elif (line == line3):
		n3 += 1
	else:
		n4 += 1

# Returns time of next event
def getNextEvent():
	return min(ta, ts, td1, td2, td3, td4, td5)

def getLongestLine():
	return max(getEstimatedWaitTime(line1), getEstimatedWaitTime(line2), getEstimatedWaitTime(line3), getEstimatedWaitTime(line4))

# Main loop
def runSimulation():
	while (True):
		# Case 1 (Arrival ocurrs before departure from any line and before closing):
		if (getNextEvent() == ta and ta < tc):

			# Update current time by time of arrival
			t = ta

			# Increment total arrivals by 1
			totalArrivals += 1

			# Add customer to "shortest" line
			addCustomerToLine(generateItemsInCart(), chooseLine())

			# Generate and set new arrival time
			ta = generateArrivalTime()

		# Cases 2-5 (Departure from one of the lines ocurrs before new arrival and before closing):
		elif (getNextEvent() == td1 and td1 < tc):

			# Update current time by earliest deparature time
			t = td1

			# Remove departed customer from line with earliest departure time
			line1.pop()



			# TODO:
				# update state variable for number of people in this line (?)

		elif (getNextEvent() == td2 and td2 < tc):

			# Update current time by earliest deparature time
			t = td2

			# Remove departed customer from line with earliest departure time
			line2.pop()

			# TODO:
				# update state variable for number of people in this line (?)

		elif (getNextEvent() == td3 and td3 < tc):

			# Update current time by earliest deparature time
			t = td3

			# Remove departed customer from line with earliest departure time
			line3.pop()

			# TODO:
				# update state variable for number of people in this line (?)

		elif (getNextEvent() == td4 and td4 < tc):

			# Update current time by earliest deparature time
			t = td4

			# Remove departed customer from line with earliest departure time
			line4.pop()

			td4

			# TODO:
				# update state variable for number of people in this line (?)


		elif ((ts < ta) and ts < getNextDepartureTime()):
			return

		# Case 6 (Next departure happens after closing and at least one customer is still in line)
		elif ((tc < getNextDepartureTime()) and (n1 + n2 + n3 + n4) != 0):

			# Update current time by earliest departure time
			updateTime(getNextDepartureTime()) 

			# Remove departed customer from line with earliest departure time
			getNextLaneDeparture().pop()

		# Case 7 (Closing time is earlier than next departure and all lines are empty):	
		elif ((tc < getNextDepartureTime()) and (n1 + n2 + n3 + n4) == 0):

			print t
			print totalArrivals
			# print any other necessary data

			# End the loop
			break

print generateArrivalTime(lam)










		
